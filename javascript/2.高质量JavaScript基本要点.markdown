1. 编写可维护的代码;

2. 减少使用全局对象：
	（1）全局变量的问题是，它们在JavaScript代码执行期间或者整个web页面中始终是可见的。它们存在于同一个命名空间中，因此命名冲突的情况时有发生，毕竟在应用程序的不同模块中，经常会出于某种目的定义相同的全局变量。
	（2）隐式的全局变量和显式定义的全局变量之间有着细微的差别，差别在于通过delete来删除它们的时候表现不一致。
			× 通过var创建的全局变量（在任何函数体之外创建的变量）不能被删除。
			× 没有用var创建的隐式全局变量（不考虑函数内的情况）可以被删除。
		也就是说，隐式全局变量并不算是真正的变量，但他们是全局对象的属性成员。属性是可以通过delete运算符删除的，而变量不可以被删除
		
3. 在函数的顶部使用一个单独的var语句是非常推荐的一种模式，它有如下一些好处：

	* 在同一个位置可以查找到函数所需的所有变量
	* 避免当在变量声明之前使用这个变量时产生的逻辑错误（参照下一小节“声明提前：分散的 var 带来的问题”）
	* 提醒你不要忘记声明变量，顺便减少潜在的全局变量
	* 代码量更少（输入更少且更易做代码优化）

4. 优化for循环:
	* 为for循环缓存住要遍历的数组的长度，比如下面这段代码：
		for (var i = 0, max = myarray.length; i < max; i++) {
			// do something with myarray[i]
		}
		通过这种方法只需要访问DOM节点一次以获得length，在整个循环过程中就都可以使用它。
	* 将var提到循环的外部，比如：
		function looper() {
			var i = 0,
				max,
				myarray = [];
			// ...
			for (i = 0, max = myarray.length; i < max; i++) {
				// do something with myarray[i]
			}
		}
		这种模式带来的好处就是提高了代码的一致性，因为你越来越依赖这种单var模式.
	* 将i++替换成为下面两者之一：
		i = i + 1
		i += 1
	* for模式还有两种变化的形式，做了少量改进，原因有二：
		减少一个变量（没有max）
		减量循环至0，这种方式速度更快，因为和零比较要比和非零数字或数组长度比较要高效的多
		第一种变化形式是：

			var i, myarray = [];
			for (i = myarray.length; i--;) {
				// do something with myarray[i]
			}
		第二种变化形式用到了while循环：

			var myarray = [],
				i = myarray.length;
			while (i--) {
				// do something with myarray[i]
			}
		这些小改进只体现在性能上
		
5. for-in 循环
	* or-in 循环用于对非数组对象作遍历。通过for-in进行循环也被称作“枚举”,for-in循环中属性的遍历顺序是不固定的，所以最好数组使用普通的for循环，对象使用for-in循环。
	* 使用对象的hasOwnProperty()方法将从原型链中继承来的属性过滤掉，这一点非常重要。
		var i,
		hasOwn = Object.prototype.hasOwnProperty;
		for (i in man) if (hasOwn.call(man, i)) { // filter
			console.log(i, ":", man[i]);
		}
6. （不）扩充内置原型
	我们可以扩充构造函数的prototype属性，这是一种非常强大的特性，用来为构造函数增加功能，但有时这个功能强大到超过我们的掌控.给内置构造函数比如Object()、Array()、和Function()扩充原型看起来非常诱人，但这种做法严重降低了代码的可维护性，因为它让你的代码变得难以预测。
	
7. 增强switch语句的可读性和健壮性：
	* 每个case和switch对齐（这里不考虑花括号相关的缩进规则）
	* 每个case中的代码整齐缩进
	* 每个case都以break作为结束
	* 避免连续执行多个case语句块（当省略break时会发生），如果你坚持认为连续执行多case语句块是最好的方法，请务必补充文档说明，对于其他人来说，这种情况看起来是错误的。
	* 以default结束整个switch，以确保即便是在找不到匹配项时也会有正常的结果
	
8. 避免隐式类型转换
	在JavaScript的比较操作中会有一些隐式的数据类型转换。比如诸如false == 0或""==0之类的比较都返回true。
	为了避免隐式类型转换造对程序造成干扰，推荐使用===和!===运算符，它们较除了比较值还会比较类型。
	
9. 避免使用eval()----eval()是魔鬼

10. 使用parseInt()进行数字转换
	可以使用parseInt()将字符串转换为数字。函数的第二个参数是转换基数（译注：“基数”指的是数字进制的方式），这个参数通常被省略.为了避免转换类型不一致而导致的意外结果，应当总是指定第二个参数
	字符串转换为数字还有两种方法：
		+"08" // result is 8
		Number("08") // 8
		
11. 总是使用花括号，而且总是将左花括号与上一条语句放在同一行;总是使用分号，尽管在JavaScript解析代码时会补全行末省略的分号.
	* 在函数、if-else语句、循环、对象直接量的左花括号之前补充空格（{）
	* 在右花括号和else和while之间补充空格

12. 命名规范
	* 构造器命名中的大小写,首字母大写可以提示你这是一个构造函数，而首字母小写的函数一般只认为它是普通的函数,对于构造函数，可以使用“大驼峰式”命名，比如MyConstructor()，对于函数和方法，可以采用“小驼峰式”命名，比如myFunction()，calculateArea()和getFirstName()。
	* 变量名通常采用小驼峰式命名，还有一个不错的做法是，变量所有字母都是小写，单词之间用下划线分隔，比如，first_name，favorite_bands 这种方法可以帮助你区分函数和其他标识符——原始数据类型或对象。
	* 对于那些程序运行周期内不会更改的变量使用全大写字母来命名（常量）.
	* 全局变量都大写,在私有成员或方法名之前加上下划线前缀
	* 保持注释时刻更新的习惯非常重要
	
13. 生产环境中的代码压缩（Minify）
	* 使用类似YUICompressor（Yahoo!）或Closure Compiler（Google）的压缩工具来为网页加载提速
	
14. 对代码进行JSLint检查


小结:
	本章我们讲解了编写可维护性代码的含义，本章的讨论非常重要，它不仅关系着软件项目的成功与否，还关系到参与项目的工程师的“精神健康”和“幸福指数”。随后我们讨论了一些最佳实践和模式，它们包括：

		* 减少全局对象，最好每个应用只有一个全局对象
		* 函数都使用单var模式来定义，这样可以将所有的变量放在同一个地方声明，同时可以避免“声明提前”给程序逻辑带来的影响。
		* for循环、for-in循环、switch语句、“禁止使用eval()”、不要扩充内置原型
		* 遵守统一的编码规范（在任何必要的时候保持空格、缩进、花括号和分号）和命名约定（构造函数、普通函数和变量）。
	本章还讨论了其他一些和代码本身无关的实践，这些实践和编码过程紧密相关，包括书写注释、生成API文档，组织代码评审、不要试图去手动了“压缩”（minify）代码而牺牲代码可读性、坚持使用JSLint来对代码做检查。


